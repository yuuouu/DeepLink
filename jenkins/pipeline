// Jenkins Declarative Pipeline for Android packaging
// 本脚本基于实践部分的经验进行改进，重点提升稳定性并添加注释说明。

pipeline {
    // 在任意可用的代理节点执行任务
    agent any

    /**
     * 环境变量区
     * 在这里定义的变量可以在整个流水线中使用。某些变量可以由外部触发参数覆盖，
     * 因此尽量不要在此定义具体敏感信息（如凭证），可通过 Jenkins 凭据插件传入。
     */
    environment {
        // Git 仓库地址（可根据需要修改）
        GIT_REPO = 'https://github.com/yuuouu/DeepLink.git'
        // 构建类型（debug 或 release），对应 Gradle task 名称
        MATRIX = "debug"
        // 标记上传和通知开关
        PGYER = "false"     // 是否上传蒲公英，传入 true 则执行
        DINGDING = "false"  // 是否发送钉钉通知，传入 true 则执行
        // APK 输出目录，Gradle 会将构建结果放在此目录下的子目录
        APK_OUTPUT_DIR = "${WORKSPACE}/app/build/outputs/apk"
        // 构建分支，默认 master，如需构建其他分支可在外部参数中覆盖
        BRANCH = "master"
        // 初始化失败原因变量，便于在失败时记录
        FAILURE_REASON = ""
    }

    stages {
        /**
         * Stage: 编译 APK
         * 调用 Gradle 任务进行编译，并生成 apk 文件。根据 MATRIX 的值选择 debug 或 release 版本。
         */
        stage('Build') {
            steps {
                script {
                    try {
                        // 在缺少 local.properties 的情况下指定 Android SDK 路径
                        def propsFile = "${WORKSPACE}/local.properties"
                        if (!fileExists(propsFile)) {
                            writeFile file: propsFile, text: 'sdk.dir=/root/Android/Sdk'
                        }
                        // 赋予 gradlew 可执行权限
                        sh 'chmod +x gradlew'
                        // 将 debug/release 首字母大写以匹配 Gradle 任务
                        def capitalizedMatrix = env.MATRIX[0].toUpperCase() + env.MATRIX.substring(1)
                        echo "Running Gradle task: assemble${capitalizedMatrix}"
                        // 执行编译
                        sh "sudo ./gradlew clean assemble${capitalizedMatrix}"
                        echo "Gradle build succeeded: assemble${capitalizedMatrix}"
                    } catch (Exception e) {
                        // 捕获异常并记录原因
                        env.FAILURE_REASON = "Gradle build failed: ${e.message}"
                        error(env.FAILURE_REASON)
                    }
                }
            }
        }

        /**
         * Stage: 上传至蒲公英
         * 当 PGYER 为 true 时执行上传操作。上传脚本需要依赖 upload_to_pgyer.py 和 Python3 环境。
         */
        stage('Upload APK to Pgyer') {
            // 只有 PGYER 环境变量为 'true'（忽略大小写）时才执行
            when {
                expression { env.PGYER?.toLowerCase() == 'true' }
            }
            steps {
                script {
                    try {
                        env.START_UPLOAD_TIME = new Date().format('yyyy-MM-dd HH:mm:ss')
                        env.START_UPLOAD_TIMESTAMP = System.currentTimeMillis()
                        // 构造 apk 路径，默认在 APK_OUTPUT_DIR/MATRIX 下寻找第一个 apk 文件
                        def apkDir = "${env.APK_OUTPUT_DIR}/${env.MATRIX}"
                        // 查找第一个 APK 文件的文件名
                        def apkFileName = sh(script: "find ${apkDir} -type f -name '*.apk' | head -n 1 | xargs -n 1 basename", returnStdout: true).trim()
                        if (!apkFileName) {
                            error("No APK file found under ${apkDir}")
                        }
                        def apkPath = "${apkDir}/${apkFileName}"
                        if (!fileExists(apkPath)) {
                            error("APK file not found: ${apkPath}")
                        }
                        // 校验上传脚本是否存在
                        if (!fileExists('upload_to_pgyer.py')) {
                            error('Missing upload_to_pgyer.py script in workspace.')
                        }
                        // 读取上传参数，若不存在则使用默认值
                        def installType = env.INSTALL_TYPE ?: '1'
                        def password    = env.PASSWORD ?: ''
                        def updateDesc  = env.UPDATE ?: '更新说明'
                        echo "Uploading APK to Pgyer: ${apkPath}"
                        // 执行 Python 脚本上传
                        def pyOutput = sh(
                            script: "python3 -u upload_to_pgyer.py --file '${apkPath}' --install_type ${installType} --password '${password}' --update_description '${updateDesc}'",
                            returnStdout: true
                        ).trim()
                        echo "Upload script output: ${pyOutput}"
                        // 读取上传结果 JSON
                        def resultJson = readJSON file: 'upload_result.json'
                        if (resultJson.code != 0) {
                            error("Failed to upload APK: ${resultJson.message}")
                        }
                        def data = resultJson.data
                        // 保存返回信息用于后续通知
                        env.appVersion     = data?.buildVersion
                        env.appShortcutUrl = data?.buildShortcutUrl
                        env.appUpdated     = data?.buildUpdated
                        env.appQRCodeURL   = data?.buildQRCodeURL
                    } catch (Exception e) {
                        env.FAILURE_REASON = "Upload to Pgyer failed: ${e.message}"
                        throw e
                    }
                }
            }
        }

        /**
         * Stage: 发送钉钉通知
         * 当 DINGDING 为 true 时执行。需要 name_to_phone.json 映射表和钉钉机器人 token。
         */
        stage('Post DingTalk') {
            when {
                expression { env.DINGDING?.toLowerCase() == 'true' }
            }
            steps {
                script {
                    try {
                        // 加载姓名与电话的映射文件，用于@具体人员
                        def nameMap = loadNameToPhoneMap()
                        def atList = []
                        // 处理构建人
                        if (env.NAME) {
                            atList << (nameMap.get(env.NAME) ?: env.NAME)
                        }
                        // 处理额外艾特人员，多个以逗号分隔
                        if (env.AT) {
                            env.AT.replaceAll(/[\[\] ]/, '').split(',').each { nm ->
                                if (nm) atList << (nameMap.get(nm) ?: nm)
                            }
                        }
                        // 从凭据中获取钉钉机器人 ID（推荐），若未配置则使用默认 env.robot
                        def robotId = env.robot ?: 'your-dingtalk-robot-id'
                        // 构造文本和链接
                        def title = env.UPDATE ?: '新版本发布'
                        def link  = env.appShortcutUrl ? "https://www.pgyer.com/${env.appShortcutUrl}" : ''
                        def qrImg = env.appQRCodeURL ?: ''
                        echo "Sending DingTalk notification to ${atList}" 
                        dingtalk(
                            robot: robotId,
                            type : 'MARKDOWN',
                            title: title,
                            text : [
                                "### ${title}",
                                "- 分支: ${env.BRANCH}",
                                "- 版本: ${env.appVersion ?: '未知'}",
                                link ? "[点击下载](${link})" : ''
                            ].findAll { it },
                            at   : atList
                        )
                    } catch (Exception e) {
                        // 不影响主流程，仅记录错误
                        echo "DingTalk notification failed: ${e.message}"
                    }
                }
            }
        }
    }

    // post 块在所有 stages 结束后执行，用于记录结果和错误
    post {
        success {
            script {
                echo 'Pipeline executed successfully.'
            }
        }
        failure {
            script {
                echo 'Pipeline failed.'
            }
        }
    }
}

/**
 * 从 JSON 文件读取姓名与电话映射，文件名称为 name_to_phone.json。
 * 如果文件不存在则抛出错误，确保不会误报通知。
 */
def loadNameToPhoneMap() {
    def mapFile = 'name_to_phone.json'
    if (!fileExists(mapFile)) {
        error "Mapping file not found: ${mapFile}"
    }
    return readJSON(file: mapFile)
}