pipeline {
    agent any
    environment {
        GIT_REPO = 'https://github.com/yuuouu/DeepLink.git'
        CSV_FILE = "${WORKSPACE}/yuu.csv"
        MATRIX = "debug"
        FAILURE_REASON = ""
        PGYER="false"
        DINGDING="false"
        APK_PATH="${WORKSPACE}/app/build/outputs/apk/"
    }
    stages {
    
        stage('Query Git Commits') {
            steps {
                script {
                    env.START_BUILD_TIME = new Date().format('yyyy-MM-dd HH:mm:ss')
                    env.START_BUILD_TIMESTAMP = System.currentTimeMillis()
                    def command = "git log -n 5 --pretty=\"%cn %cI %s\""
                    def recentCommits = sh(script: command, returnStdout: true).trim()
                    env.recentCommits = recentCommits
                    def firstGitLine = recentCommits.tokenize('\n')[0]
                    env.firstGitLine = firstGitLine
                    echo "ÂØπÂ§ñËæìÂá∫ÁöÑlog: ${firstGitLine}"
                }
            }
        }

        stage('Build') {
            steps {
                script {
                    try {
                        def settingsGradleFile = "${WORKSPACE}/local.properties"
                        if (!fileExists(settingsGradleFile)) {
                            writeFile file: settingsGradleFile, text: 'sdk.dir="/root/Android/Sdk"'
                        }
                        sh "sudo chmod +x gradlew"
                        def capitalizedMatrix = MATRIX[0].toUpperCase() + MATRIX.substring(1)
                        sh "sudo ./gradlew clean assemble${capitalizedMatrix}"
                        echo "Gradle ÊûÑÂª∫‰ªªÂä°ÊâßË°åÊàêÂäü  ${capitalizedMatrix}"
                    } catch (Exception e) {
                        FAILURE_REASON = "Gradle ÊûÑÂª∫Â§±Ë¥•: ${e.message}"
                        error(FAILURE_REASON)
                    }
                }
            }
        }

        stage('Upload APK to Pgyer') {
            when {
                 expression { PGYER?.toLowerCase() == 'true' }
            }
            steps {
                script {
                    try {
                        env.START_UPLOAD_TIME = new Date().format('yyyy-MM-dd HH:mm:ss')
                        env.START_UPLOAD_TIMESTAMP = System.currentTimeMillis()
                        def apkDir = APK_PATH + MATRIX
                        def apkFiles = sh(script: """
                                firstApk=\$(find ${apkDir} -name "*.apk" | head -n 1)
                                echo \$firstApk | xargs -n 1 basename
                            """, returnStdout: true).trim()
                        if (apkFiles.isEmpty()) {
                            error("Êú™ÊâæÂà∞ APK Êñá‰ª∂„ÄÇ")
                        }
                        def apkPath = "${apkDir}/${apkFiles}"
                        if (!fileExists(apkPath)) {
                            error("Êñá‰ª∂ ${apkPath} ‰∏çÂ≠òÂú®„ÄÇ")
                        }
                        env.INSTALL_TYPE = (env.INSTALL_TYPE && env.INSTALL_TYPE != 'null') ? env.INSTALL_TYPE : '1'
                        echo "üì§ ÂáÜÂ§á‰∏ä‰º† APK Âà∞Ëí≤ÂÖ¨Ëã±..."
                        def output = sh (
                            script: """
                                python3 -u upload_to_pgyer.py \
                                    --file ${apkPath} \
                                    --install_type ${env.INSTALL_TYPE} \
                                    --password '${env.PASSWORD}' \
                                    --update_description '${env.UPDATE}'
                            """,
                            returnStdout: true
                        ).trim()
                        echo "py: ${output}"

                        def result = readJSON file: 'upload_result.json'
                        if (result.code != 0) {
                            error "‰∏ä‰º†Â§±Ë¥•: ${result.message}"
                        }
                        def data = result['data']
                        env.appVersion = data?.buildVersion
                        env.appShortcutUrl = data?.buildShortcutUrl
                        env.appUpdated = data?.buildUpdated
                        env.appQRCodeURL = data?.buildQRCodeURL
                    } catch (Exception e) {
                        FAILURE_REASON = "‰∏ä‰º†APKÂ§±Ë¥•: ${e.message}"
                        throw e
                    }
                }
            }
        }

        stage('Post DingDing') {
            when {
                 expression { DINGDING?.toLowerCase() == 'true' }
            }
            steps {
                script {
                    try {
                        def nameToPhoneMap = loadNameToPhoneMap()
                        def atList = []
                        if (env.NAME) {
                            atList.add(nameToPhoneMap.get(env.NAME) ?: env.NAME)
                        }
                        if (env.AT) {
                            def names = env.AT.replaceAll("[\\[\\] ]", "").split(",")
                            for (name in names) {
                                atList.add(nameToPhoneMap.get(name) ?: name)
                            }
                        }
                        env.robot = '2333'
                        dingtalk(
                            robot: env.robot,
                            type: 'MARKDOWN',
                            title: env.UPDATE,
                            text: [
                            "### ${env.UPDATE}",
                            '---',
                            "- ÊûÑÂª∫ÂàÜÊîØ: ${env.BRANCH}",
                            "- ÊûÑÂª∫Á±ªÂûã: ${MATRIX}",
                            "- ÊûÑÂª∫ÁâàÊú¨: ${env.appVersion}",
                            '---',
                            "[https://www.pgyer.com/${env.appShortcutUrl}](https://www.pgyer.com/${env.appShortcutUrl})",
                            "![‰∫åÁª¥Á†Å](${env.appQRCodeURL})"
                            ],
                            at: atList
                        )
                    } catch (Exception e) {
                        echo "ÈíâÈíâÊé®ÈÄÅÂ§±Ë¥•: ${e.message}"
                    }
                }
            }
        }

        stage('Log to CSV') {
            when {
                 expression { DINGDING?.toLowerCase() == 'true' }
            }
            steps {
                script {
                    try {
                        writeCsvLog(true, "")
                    } catch (e) {
                        echo "CSVÊó•ÂøóËÆ∞ÂΩïÂ§±Ë¥•: ${e.message}"
                    }
                }
            }
        }
    }

    post {
        success {
            echo 'Pipeline executed successfully!'
            echo "ÊúÄËøë ${env.query} Ê¨°Êèê‰∫§‰ø°ÊÅØÔºö\n${env.recentCommits}"
            echo "ÂºÄÂßãÊûÑÂª∫Êó∂Èó¥: ${env.START_BUILD_TIME}"
            echo "ÂºÄÂßã‰∏ä‰º†Êó∂Èó¥: ${env.START_UPLOAD_TIME}"
            echo "ÊûÑÂª∫ÂÆåÊàêÊó∂Èó¥: ${env.appUpdated}"
        }
        failure {
            script {
                try {
                    writeCsvLog(false, FAILURE_REASON ?: "")
                } catch (e) {
                    echo "Â§±Ë¥•ÊÉÖÂÜµCSVÊó•ÂøóËÆ∞ÂΩïÂ§±Ë¥•: ${e.message}"
                }
            }
            echo 'Pipeline failed!'
        }
    }
}

// ‰ªéÂ§ñÈÉ®Êñá‰ª∂ËØªÂèñÂßìÂêç‰∏éÁîµËØùÊò†Â∞Ñ
def loadNameToPhoneMap() {
    def mapFile = "name_to_phone.json"
    if (!fileExists(mapFile)) {
        error("Áº∫Â∞ëÊò†Â∞ÑÊñá‰ª∂: ${mapFile}")
    }
    return readJSON(file: mapFile)
}

// Áªü‰∏Ä CSV ÂÜôÂÖ•ÊñπÊ≥ï
def writeCsvLog(boolean success, String failureReason = "") {
    def endTimestamp = System.currentTimeMillis()
    def startTimestamp = Long.parseLong(env.START_BUILD_TIMESTAMP ?: "0")
    def uploadTimestamp = Long.parseLong(env.START_UPLOAD_TIMESTAMP ?: startTimestamp.toString())

    def totalDuration = formatDuration(endTimestamp - startTimestamp)
    def buildDuration = formatDuration(uploadTimestamp - startTimestamp)
    def uploadDuration = formatDuration(endTimestamp - uploadTimestamp)

    def transmissionData = [
        "branch"  : env.BRANCH ?: "",
        "name"    : env.NAME ?: "",
        "update"  : env.UPDATE ?: "",
        "at"      : env.AT ?: "",
        "test"    : env.TEST ?: "",
        "matrix"  : MATRIX ?: "",
        "password": env.PASSWORD ? "***" : "",
        "query"   : env.query ?: 5,
        "shortcut": env.SHORTCUT ?: ""
    ]
    def transmissionJson = groovy.json.JsonOutput.toJson(transmissionData)

    def pushInfo = ""
    if (success && env.TEST?.toLowerCase() == 'true' && env.outtext) {
        pushInfo = env.outtext.toString().replaceAll('\\[|\\]', '').replaceAll(', ', ' ')
    }

    def csvRecord = [
        totalDuration,
        buildDuration,
        uploadDuration,
        env.START_BUILD_TIME ?: "",
        success.toString(),
        (env.firstGitLine ?: "").replaceAll(',', ';'),
        pushInfo.replaceAll(',', ';'),
        failureReason.replaceAll(',', ';'),
        transmissionJson.replaceAll(',', ';')
    ].collect { "\"${it}\"" }.join(',')

    def csvRecordoutput = sh (
        script: """
            python3 -u save.py \
                --csv '${csvRecord}'
        """,
        returnStdout: true
    ).trim()
    echo "csvRecord: ${csvRecord}"
    echo "py output: ${csvRecordoutput}"
    echo ' out ${env.CSV_FILE}'
}

// Êó∂Èó¥Ê†ºÂºèÂåñ
def formatDuration(long milliseconds) {
    long seconds = milliseconds / 1000
    long minutes = seconds / 60
    seconds = seconds % 60
    return String.format("%02d:%02d", minutes, seconds)
}
